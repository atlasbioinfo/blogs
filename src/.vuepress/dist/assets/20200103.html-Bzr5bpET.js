import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as a,c as s,e}from"./app-B1UaDH9J.js";const l={},p=e(`<p>最近要批量整理一大堆BAM数据，批量Map到转录组固定位点。写了一个单线程的程序，估计了一下，跑完估计得2天，完全等不了。所以开始写准备写perl语言的多线程，经过半个下午的折腾，终于找到了靠谱的方法。感叹一下，perl是不是已经被抛弃了，现在真心是python的天下。</p><blockquote><ul><li>项目的多线程需求</li><li>多线程模块Parallel::ForkManager</li><li>血泪史</li><li>我对Perl语言的理解</li></ul></blockquote><hr><h2 id="项目的多线程需求" tabindex="-1"><a class="header-anchor" href="#项目的多线程需求"><span>项目的多线程需求</span></a></h2><p>我现在把文件压缩成bam格式并且index，现在需要把reads的位点定位在转录本的固定位点上。也就是这是一个单线程不怎么耗时的任务，需要用大量多线程并发来提高效率。</p><p>所以单线程任务为：</p><ul><li>调用用samtools提取转录本所在的位置的所有reads</li><li>用perl处理后在数组固定位置加1</li><li>将数组输出到文件</li></ul><p>每个单线程耗时很短，最耗时的可能是调用samtools，不过因为bam我都进行index了，几乎秒查。</p><p>如果需要多线程，那么需求为：</p><ul><li>同时提交多个单线程任务，线程之间数据不共享</li><li>数据输出到文件的时候，多线程不能冲突（比如多个线程同时往一个文件中数据，那结果就乱了）</li><li>最好能控制一下线程数量，不能一次提交全部线程。</li></ul><h2 id="多线程模块parallel-forkmanager" tabindex="-1"><a class="header-anchor" href="#多线程模块parallel-forkmanager"><span>多线程模块Parallel::ForkManager</span></a></h2><p>人生苦短，我用Parallel::ForkManager，不用threads：）</p><p>这个模块优点就是，CPAN上有详细的API，作者也给出了多个示例供参考，几行代码轻松实现多线程=-=，这就是我需要的模块。</p><h3 id="安装parallel-forkmanager" tabindex="-1"><a class="header-anchor" href="#安装parallel-forkmanager"><span>安装Parallel::ForkManager</span></a></h3><p>我用CPAN安装</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>cpan Parallel::ForkManager
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>对于国内的朋友需要改一下源：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment">#如果你知道Config.pm或者MyConfig.pm在哪，那就直接打开，把下面的这行修改成163的源</span>
<span class="token string">&#39;urllist&#39;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span>q<span class="token punctuation">[</span>http://mirrors.163.com/cpan/<span class="token punctuation">]</span><span class="token punctuation">]</span>

<span class="token comment">#如果你不知道配置文件在哪，可以命令行：cpan</span>
$ cpan
Loading internal logger. Log::Log4perl recommended <span class="token keyword">for</span> better logging
Terminal does not support AddHistory.

To fix that, maybe try<span class="token operator">&gt;</span>  <span class="token function">install</span> Term::ReadLine::Perl


cpan shell -- CPAN exploration and modules installation <span class="token punctuation">(</span>v2.27<span class="token punctuation">)</span>
Enter <span class="token string">&#39;h&#39;</span> <span class="token keyword">for</span> help.
<span class="token comment">#输入</span>
cpan<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> o conf
<span class="token variable">$CPAN</span>::Config options from /home/xxx/.cpan/CPAN/MyConfig.pm:
    commit             <span class="token punctuation">[</span>Commit changes to disk<span class="token punctuation">]</span>
    defaults           <span class="token punctuation">[</span>Reload defaults from disk<span class="token punctuation">]</span>
    <span class="token builtin class-name">help</span>               <span class="token punctuation">[</span>Short <span class="token builtin class-name">help</span> about <span class="token string">&#39;o conf&#39;</span> usage<span class="token punctuation">]</span>

<span class="token comment">#上面显示配置文件的路径，可以直接打开文件修改，或者</span>
o conf urllist q<span class="token punctuation">[</span>http://mirrors.163.com/cpan/<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>装好之后，可以先use测试一下</p><div class="language-perl line-numbers-mode" data-ext="perl" data-title="perl"><pre class="language-perl"><code><span class="token keyword">use</span> Parallel<span class="token punctuation">:</span><span class="token punctuation">:</span>ForkManager
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果报错的话，仔细看错误，我在装的时候提示还有一个包没有装(如果是路径不对就自行调整)，Moo::Role。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>cpan Moo::Role
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>之后就能运行啦~</p><h3 id="语法" tabindex="-1"><a class="header-anchor" href="#语法"><span>语法</span></a></h3><p>我对于多线程理解的语法应该类似于这样的：</p><div class="language-perl line-numbers-mode" data-ext="perl" data-title="perl"><pre class="language-perl"><code><span class="token comment">#伪代码，伪代码</span>
$最大线程数<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token keyword">my</span> <span class="token variable">$i</span><span class="token punctuation">(</span>@你的所有任务<span class="token punctuation">)</span><span class="token punctuation">{</span>

    $开始多线程
    单线程任务<span class="token punctuation">(</span>一些参数<span class="token punctuation">)</span>
    $结束多线程

<span class="token punctuation">}</span>

<span class="token keyword">sub</span> 单线程任务<span class="token punctuation">{</span>
    <span class="token operator">...</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里先把所有线程安排到一个“等待队列”里面，同时有一个有限长度的“工作队列”。完成一个，出“工作队列”，同时从“等待队列”取出一个加入“工作队列”保持最大“工作队列长度”。</p><p>或者是没有“等待队列”，&quot;工作队列&quot;有空缺了，再生成一个任务补进去。这种听起来似乎更节约内存。</p><p>虽然不知道FolkManager究竟的内部逻辑是什么，但是语法逻辑和上面的一样，很便于理解。</p><div class="language-perl line-numbers-mode" data-ext="perl" data-title="perl"><pre class="language-perl"><code><span class="token comment">#最简单的ForkManager</span>
<span class="token keyword">use</span> strict<span class="token punctuation">;</span><span class="token keyword">use</span> warnings<span class="token punctuation">;</span>
<span class="token keyword">use</span> Parallel<span class="token punctuation">:</span><span class="token punctuation">:</span>ForkManager<span class="token punctuation">;</span>
<span class="token comment"># 这里设置最大线程数为20</span>
<span class="token keyword">my</span> <span class="token variable">$pm</span><span class="token operator">=</span>Parallel<span class="token punctuation">:</span><span class="token punctuation">:</span>ForkManager<span class="token operator">-&gt;</span>new<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>

<span class="token keyword">my</span> <span class="token variable">@jobs</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token keyword">my</span> <span class="token variable">$i</span><span class="token punctuation">(</span><span class="token variable">@jobs</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">#在循环中写上开始、结束和你想要做的事情</span>
    <span class="token variable">$pm</span> <span class="token operator">-&gt;</span>start <span class="token operator">and</span> <span class="token keyword">next</span> <span class="token punctuation">;</span>

    这里写上你想让多线程做的事情

    <span class="token variable">$pm</span> <span class="token operator">-&gt;</span>finish<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token variable">$pm</span><span class="token operator">-&gt;</span>wait_all_children<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>完美！</p><h3 id="解决输出问题" tabindex="-1"><a class="header-anchor" href="#解决输出问题"><span>解决输出问题</span></a></h3><p>刚才提到了还有一个问题，就是多线程会一起输出。如果几个线程同时写文件就会出现错乱，如果写到不同的文件倒是一个方案，但是最后cat的压力就比较大，我这个共几千万个转录本，最后就是几千万个文件的cat，实在崩溃。</p><p>我发现添加下面的语句，就不会出现错乱问题。就是设置在子线程计算完成的时候，都要运行这个程序，统一输出，吧......我也不知道为什么，但是，it work!</p><div class="language-perl line-numbers-mode" data-ext="perl" data-title="perl"><pre class="language-perl"><code>    <span class="token keyword">my</span> <span class="token variable">$pm</span><span class="token operator">=</span>Parallel<span class="token punctuation">:</span><span class="token punctuation">:</span>ForkManager<span class="token operator">-&gt;</span>new<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>
    <span class="token comment">#定义完之后定义下面的，run_on_finish</span>
    <span class="token variable">$pm</span> <span class="token operator">-&gt;</span> run_on_finish<span class="token punctuation">(</span>
        <span class="token keyword">sub</span> <span class="token punctuation">{</span>
            <span class="token keyword">my</span> <span class="token punctuation">(</span><span class="token variable">$pid</span><span class="token punctuation">,</span> <span class="token variable">$exit_code</span><span class="token punctuation">,</span> <span class="token variable">$ident</span><span class="token punctuation">,</span> <span class="token variable">$exit_signal</span><span class="token punctuation">,</span> <span class="token variable">$core_dump</span><span class="token punctuation">,</span> <span class="token variable">$data_structure_reference</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token variable">@_</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>defined<span class="token punctuation">(</span><span class="token variable">$data_structure_reference</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">my</span> <span class="token variable">$string</span> <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">{</span><span class="token variable">$data_structure_reference</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
                <span class="token keyword">print</span> <span class="token variable">$string</span><span class="token punctuation">,</span><span class="token string">&quot;\\n&quot;</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">#在循环中写finish的时候，改成以下写法：</span>
    <span class="token variable">$pm</span> <span class="token operator">-&gt;</span>finish<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">\\</span><span class="token variable">$report</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">#这里的$report就是我期望子线程输出的内容，一定要记住这个反斜杠\\，别忘加了</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（我也不知道为什么，但是我这么写之后，确实不会出现输出文件错乱问题了。如果哪个大佬知道为什么，求告知，不胜感谢）</p><h2 id="血泪史" tabindex="-1"><a class="header-anchor" href="#血泪史"><span>血泪史</span></a></h2><p>也不算血泪史，毕竟才折腾了半个下午，还没有写这个博客耗时长=-=。</p><p>首先我当时用了threads，但是这个模块我知道怎么创建线程，怎么回收线程，但是怎么控制线程的数量啊？</p><p>之后我知道Thread::Pool模块，其中还有一个Thread::Pool::Simple模块，看起来就简单易行。然鹅，感觉bug的是，运行后直接运行了所有是threads，并没有控制数量，并且线程还没结束就join了-0-。</p><p>然后我觉得，要不还是用Thread::Pool好了。结果，我想要一个例子=-=，但是没有，作者没有在CPAN里面给，同时全网搜都木有。</p><p>最后用了FolkManager，舒服了。。。简单易行，作者给了详细的例子，我自己写了几个Demo后就直接上服务器了，感觉效率爆表。</p><h2 id="我对perl语言的理解" tabindex="-1"><a class="header-anchor" href="#我对perl语言的理解"><span>我对Perl语言的理解</span></a></h2><p>我的小骆驼啊~</p><p>从进实验室的第一天，师兄、老师就让我学Perl语言，当时实验室还在用的还有MatLab, C++, Java。不过当时做生物信息很多大佬用perl的很多，原因是处理文本比较快且容易学，代码写起来长度短，无视数据类型全靠上下文等。</p><p>然鹅，现在，实验室的小朋友们统一在学，Python =-=！</p><p>但是在服务器写代码，我还是喜欢用Perl，因为写起来快，运行起来快，并且最重要的是**不需要考虑缩进!**我对于Perl语言的理解就是，我觉得它是一个脚本语言，用Perl可以更好的代替cat, awk, grep等shell的命令完成更复杂的工作，所以以后如果需要管服务器或者写比较麻烦的shell的时候，我还是用Perl好了。</p><p>但是现在问题就是，如果你写perl程序遇到问题了，这时候就麻烦了。Perl的社区有限活跃度及其一般，经常搜不到你想要的，只能自己摸索。很多包没有现成的，需要自己写。</p><p>今天想研究一下多线程，基础模块threads的教程倒是很多但是无法满足我的需求，找了半天，终于找到了Parallel::ForkManager模块，感觉这个模块更像个线程池，终于实现了需求。</p><figure><img src="https://pic.atlasbioinfo.com/logo.png" alt="博主简介" tabindex="0" loading="lazy"><figcaption>博主简介</figcaption></figure>`,50),t=[p];function i(o,r){return a(),s("div",null,t)}const u=n(l,[["render",i],["__file","20200103.html.vue"]]),k=JSON.parse('{"path":"/posts/Perl/20200103.html","title":"Perl语言多线程的简单实现","lang":"zh-CN","frontmatter":{"icon":"code","date":"2020-01-03T00:00:00.000Z","title":"Perl语言多线程的简单实现","categories":["Perl"],"description":"最近要批量整理一大堆BAM数据，批量Map到转录组固定位点。写了一个单线程的程序，估计了一下，跑完估计得2天，完全等不了。所以开始写准备写perl语言的多线程，经过半个下午的折腾，终于找到了靠谱的方法。感叹一下，perl是不是已经被抛弃了，现在真心是python的天下。 项目的多线程需求 多线程模块Parallel::ForkManager 血泪史 我...","head":[["meta",{"property":"og:url","content":"https://blog.atlasbioinfo.com/posts/Perl/20200103.html"}],["meta",{"property":"og:site_name","content":"ATLAS生物信息博客"}],["meta",{"property":"og:title","content":"Perl语言多线程的简单实现"}],["meta",{"property":"og:description","content":"最近要批量整理一大堆BAM数据，批量Map到转录组固定位点。写了一个单线程的程序，估计了一下，跑完估计得2天，完全等不了。所以开始写准备写perl语言的多线程，经过半个下午的折腾，终于找到了靠谱的方法。感叹一下，perl是不是已经被抛弃了，现在真心是python的天下。 项目的多线程需求 多线程模块Parallel::ForkManager 血泪史 我..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://pic.atlasbioinfo.com/logo.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-20T11:04:46.000Z"}],["meta",{"property":"article:author","content":"Haopeng Yu"}],["meta",{"property":"article:published_time","content":"2020-01-03T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-20T11:04:46.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Perl语言多线程的简单实现\\",\\"image\\":[\\"https://pic.atlasbioinfo.com/logo.png\\"],\\"datePublished\\":\\"2020-01-03T00:00:00.000Z\\",\\"dateModified\\":\\"2024-03-20T11:04:46.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Haopeng Yu\\",\\"url\\":\\"https://github.com/atlasbioinfo\\"}]}"]]},"headers":[{"level":2,"title":"项目的多线程需求","slug":"项目的多线程需求","link":"#项目的多线程需求","children":[]},{"level":2,"title":"多线程模块Parallel::ForkManager","slug":"多线程模块parallel-forkmanager","link":"#多线程模块parallel-forkmanager","children":[{"level":3,"title":"安装Parallel::ForkManager","slug":"安装parallel-forkmanager","link":"#安装parallel-forkmanager","children":[]},{"level":3,"title":"语法","slug":"语法","link":"#语法","children":[]},{"level":3,"title":"解决输出问题","slug":"解决输出问题","link":"#解决输出问题","children":[]}]},{"level":2,"title":"血泪史","slug":"血泪史","link":"#血泪史","children":[]},{"level":2,"title":"我对Perl语言的理解","slug":"我对perl语言的理解","link":"#我对perl语言的理解","children":[]}],"git":{"createdTime":1710932686000,"updatedTime":1710932686000,"contributors":[{"name":"hyu","email":"hp.yu@outlook.com","commits":1}]},"readingTime":{"minutes":6.31,"words":1893},"filePathRelative":"posts/Perl/20200103.md","localizedDate":"2020年1月3日","excerpt":"<p>最近要批量整理一大堆BAM数据，批量Map到转录组固定位点。写了一个单线程的程序，估计了一下，跑完估计得2天，完全等不了。所以开始写准备写perl语言的多线程，经过半个下午的折腾，终于找到了靠谱的方法。感叹一下，perl是不是已经被抛弃了，现在真心是python的天下。</p>\\n<blockquote>\\n<ul>\\n<li>项目的多线程需求</li>\\n<li>多线程模块Parallel::ForkManager</li>\\n<li>血泪史</li>\\n<li>我对Perl语言的理解</li>\\n</ul>\\n</blockquote>\\n<hr>\\n<h2>项目的多线程需求</h2>\\n<p>我现在把文件压缩成bam格式并且index，现在需要把reads的位点定位在转录本的固定位点上。也就是这是一个单线程不怎么耗时的任务，需要用大量多线程并发来提高效率。</p>","autoDesc":true}');export{u as comp,k as data};
